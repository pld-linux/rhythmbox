diff -urN rhythmbox-0.11.4/configure.ac rhythmbox-0.11.4.new/configure.ac
--- rhythmbox-0.11.4/configure.ac	2007-12-20 11:56:44.000000000 +0000
+++ rhythmbox-0.11.4.new/configure.ac	2008-02-06 00:57:27.000000000 +0000
@@ -441,18 +441,25 @@
 dnl Check for libsoup, needed for DAAP and audioscrobbler
 if test "x$enable_daap" = "xyes" || test "x$enable_audioscrobbler" != "xno"; then
 	PKG_CHECK_MODULES(SOUP,                            \
-		libsoup-2.2,
-		have_libsoup=yes,
-		have_libsoup=no)
-	if test x"$have_libsoup" = "xno"; then
+		libsoup-2.4,
+		have_libsoup24=yes,
+		have_libsoup24=no)
+	if test x"$have_libsoup24" = "xno"; then
 		PKG_CHECK_MODULES(SOUP,
-			libsoup-2.4,
-			have_libsoup=yes,
-			have_libsoup=no)
+			libsoup-2.2,
+			have_libsoup22=yes,
+			have_libsoup22=no)
 	fi
-	if test x"$have_libsoup" = "xyes"; then
+	if test x"$have_libsoup24" = "xyes" || test x"$have_libsoup22" = "xyes"; then
+		have_libsoup=yes
 		AC_DEFINE(HAVE_LIBSOUP, 1, [Define if libsoup support is enabled])
 	fi
+	if test x"$have_libsoup24" = "xyes"; then
+		AC_DEFINE(HAVE_LIBSOUP_2_4, 1, [Define if libsoup 2.4 support is enabled])
+	fi
+	if test x"$have_libsoup22" = "xyes"; then
+		AC_DEFINE(HAVE_LIBSOUP_2_2, 1, [Define if libsoup 2.2 support is enabled])
+	fi
 fi
 
 AM_CONDITIONAL(USE_LIBSOUP, test x"$have_libsoup" = "xyes")
@@ -513,27 +520,9 @@
 
 
 
-AC_PATH_X
-
-if test x"$x_includes" != x"NONE" && test -n "$x_includes" ; then
-	CFLAGS=$CFLAGS -I`echo $x_includes | sed -e "s/:/ -I/g"`
-fi
-if test x"$x_libraries" != x"NONE" && test -n "$x_libraries" ; then
-	LIBS=-L`echo $x_libraries | sed -e "s/:/ -L/g"`
-fi
-
-have_xidle=no
-AC_COMPILE_IFELSE([
-	#include <X11/extensions/xidle.h>
-int main(int argc,char **argv) {
-  return 0;
-}
-], have_xidle=yes)
-AC_MSG_CHECKING(for XIDLE extension)
-AC_MSG_RESULT($have_xidle)
-if test x"$have_xidle" = "xyes" ; then
-	AC_DEFINE(HAVE_XIDLE_EXTENSION, 1, [defined if you have X11/extensions/xidle.h])
-fi
+AC_PATH_XTRA
+CFLAGS="$CFLAGS $X_CFLAGS"
+#LIBS=$X_LIBS
 
 dnl Multimedia keys
 have_xfree=no
@@ -1167,7 +1156,11 @@
 	AC_MSG_NOTICE([   CD burning support disabled])
 fi
 if test x"$enable_daap" = xyes; then
-	AC_MSG_NOTICE([** DAAP (music sharing) support is enabled])
+	if test x"$have_libsoup24" = "xyes"; then
+		AC_MSG_NOTICE([** DAAP (music sharing) support is enabled (using libsoup 2.4)])
+	elif test x"$have_libsoup22" = "xyes"; then
+		AC_MSG_NOTICE([** DAAP (music sharing) support is enabled (using libsoup 2.2)])
+	fi
 else
 	AC_MSG_NOTICE([   DAAP (music sharing) support is disabled])
 fi
@@ -1197,7 +1190,11 @@
 	AC_MSG_NOTICE([   gnome-keyring support disabled])
 fi
 if test x"$enable_audioscrobbler" != xno; then
-	AC_MSG_NOTICE([** Audioscrobbler support enabled])
+	if test x"$have_libsoup24" = "xyes"; then
+		AC_MSG_NOTICE([** Audioscrobbler support enabled (using libsoup 2.4)])
+	elif test x"$have_libsoup22" = "xyes"; then
+		AC_MSG_NOTICE([** Audioscrobbler support enabled (using libsoup 2.2)])
+	fi
 else
 	AC_MSG_NOTICE([   Audioscrobbler support disabled])
 fi
diff -urN rhythmbox-0.11.4/lib/Makefile.am rhythmbox-0.11.4.new/lib/Makefile.am
--- rhythmbox-0.11.4/lib/Makefile.am	2007-08-01 09:04:11.000000000 +0100
+++ rhythmbox-0.11.4.new/lib/Makefile.am	2008-02-06 00:57:27.000000000 +0000
@@ -34,7 +34,8 @@
 	rb-string-value-map.c				\
 	rb-string-value-map.h				\
 	rb-async-queue-watch.c				\
-	rb-async-queue-watch.h
+	rb-async-queue-watch.h				\
+	rb-soup-compat.h
 
 if WITH_INTERNAL_GSEQUENCE
 librb_la_SOURCES += gsequence.c gsequence.h
diff -urN rhythmbox-0.11.4/lib/rb-proxy-config.c rhythmbox-0.11.4.new/lib/rb-proxy-config.c
--- rhythmbox-0.11.4/lib/rb-proxy-config.c	2007-06-03 02:55:02.000000000 +0100
+++ rhythmbox-0.11.4.new/lib/rb-proxy-config.c	2008-02-06 00:57:27.000000000 +0000
@@ -231,7 +231,28 @@
 	}
 }
 
-#if defined(HAVE_LIBSOUP)
+#if defined(HAVE_LIBSOUP_2_4)
+SoupURI *
+rb_proxy_config_get_libsoup_uri (RBProxyConfig *config)
+{
+	SoupURI *uri = NULL;
+
+	if (!config->enabled)
+		return NULL;
+
+	uri = soup_uri_new (NULL);
+	soup_uri_set_scheme (uri, SOUP_URI_SCHEME_HTTP);
+	soup_uri_set_host (uri, config->host);
+	soup_uri_set_port (uri, config->port);
+
+	if (config->auth_enabled) {
+		soup_uri_set_user (uri, config->username);
+		soup_uri_set_password (uri, config->password);
+	}
+
+	return uri;
+}
+#elif defined(HAVE_LIBSOUP_2_2)
 SoupUri *
 rb_proxy_config_get_libsoup_uri (RBProxyConfig *config)
 {
diff -urN rhythmbox-0.11.4/lib/rb-proxy-config.h rhythmbox-0.11.4.new/lib/rb-proxy-config.h
--- rhythmbox-0.11.4/lib/rb-proxy-config.h	2007-06-03 02:55:02.000000000 +0100
+++ rhythmbox-0.11.4.new/lib/rb-proxy-config.h	2008-02-06 00:57:27.000000000 +0000
@@ -24,8 +24,8 @@
 #include <glib-object.h>
 
 #if defined(HAVE_LIBSOUP)
+#include "rb-soup-compat.h"
 #include <libsoup/soup.h>
-#include <libsoup/soup-uri.h>
 #endif
 
 G_BEGIN_DECLS
@@ -65,9 +65,7 @@
 
 RBProxyConfig *	rb_proxy_config_new (void);
 
-#if defined(HAVE_LIBSOUP)
-SoupUri *	rb_proxy_config_get_libsoup_uri (RBProxyConfig *config);
-#endif
+SoupURI *	rb_proxy_config_get_libsoup_uri (RBProxyConfig *config);
 
 #endif	/* RB_PROXY_CONFIG_H */
 
diff -urN rhythmbox-0.11.4/lib/rb-soup-compat.h rhythmbox-0.11.4.new/lib/rb-soup-compat.h
--- rhythmbox-0.11.4/lib/rb-soup-compat.h	1970-01-01 01:00:00.000000000 +0100
+++ rhythmbox-0.11.4.new/lib/rb-soup-compat.h	2008-02-06 00:57:27.000000000 +0000
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (C) 2008  Jonathan Matthew <jonathan@d14n.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  
+ *  02110-1301  USA
+ */
+
+#ifndef RB_SOUP_COMPAT_H
+#define RB_SOUP_COMPAT_H
+
+#include <libsoup/soup.h>
+
+/* compatibility junk for libsoup 2.2.
+ * not intended to obviate the need for #ifdefs in code, but
+ * should remove a lot of the trivial ones and make it easier
+ * to drop libsoup 2.2
+ */
+#if defined(HAVE_LIBSOUP_2_2)
+
+#include <libsoup/soup-uri.h>
+#include <libsoup/soup-address.h>
+#include <libsoup/soup-connection.h>
+#include <libsoup/soup-headers.h>
+#include <libsoup/soup-message.h>
+#include <libsoup/soup-misc.h>
+#include <libsoup/soup-session-sync.h>
+#include <libsoup/soup-server.h>
+#include <libsoup/soup-server-auth.h>
+#include <libsoup/soup-server-message.h>
+
+
+typedef SoupUri				SoupURI;
+typedef SoupMessageCallbackFn		SoupSessionCallback;
+typedef SoupServerContext		SoupClientContext;
+
+#define SOUP_MEMORY_TAKE		SOUP_BUFFER_SYSTEM_OWNED
+#define SOUP_MEMORY_TEMPORARY		SOUP_BUFFER_USER_OWNED
+
+#define soup_message_headers_append	soup_message_add_header
+#define soup_message_headers_get	soup_message_get_header
+
+#define soup_client_context_get_host	soup_server_context_get_client_host
+
+#endif	/* HAVE_LIBSOUP_2_2 */
+
+#endif	/* RB_SOUP_COMPAT_H */
+
diff -urN rhythmbox-0.11.4/plugins/audioscrobbler/rb-audioscrobbler.c rhythmbox-0.11.4.new/plugins/audioscrobbler/rb-audioscrobbler.c
--- rhythmbox-0.11.4/plugins/audioscrobbler/rb-audioscrobbler.c	2007-12-17 09:26:53.000000000 +0000
+++ rhythmbox-0.11.4.new/plugins/audioscrobbler/rb-audioscrobbler.c	2008-02-06 00:59:48.000000000 +0000
@@ -24,6 +24,8 @@
 
 #define __EXTENSIONS__
 
+#include "config.h"
+
 #include <errno.h>
 
 #include <string.h>
@@ -35,10 +37,9 @@
 #include <gtk/gtk.h>
 #include <gconf/gconf-value.h>
 
+#include "rb-soup-compat.h"
 #include <libsoup/soup.h>
-#include <libsoup/soup-uri.h>
 
-#include "config.h"
 #include "eel-gconf-extensions.h"
 #include "rb-audioscrobbler.h"
 #include "rb-debug.h"
@@ -193,14 +194,20 @@
 
 static gchar *	     mkmd5 (char *string);
 static void	     rb_audioscrobbler_parse_response (RBAudioscrobbler *audioscrobbler, SoupMessage *msg);
-static void	     rb_audioscrobbler_perform (RBAudioscrobbler *audioscrobbler,
-					       char *url,
-					       char *post_data,
-						   SoupMessageCallbackFn response_handler);
+
 static void	     rb_audioscrobbler_do_handshake (RBAudioscrobbler *audioscrobbler);
-static void	     rb_audioscrobbler_do_handshake_cb (SoupMessage *msg, gpointer user_data);
 static void	     rb_audioscrobbler_submit_queue (RBAudioscrobbler *audioscrobbler);
+static void	     rb_audioscrobbler_perform (RBAudioscrobbler *audioscrobbler,
+						char *url,
+						char *post_data,
+						SoupSessionCallback response_handler);
+#if defined(HAVE_LIBSOUP_2_4)
+static void	     rb_audioscrobbler_do_handshake_cb (SoupSession *session, SoupMessage *msg, gpointer user_data);
+static void	     rb_audioscrobbler_submit_queue_cb (SoupSession *session, SoupMessage *msg, gpointer user_data);
+#else
+static void	     rb_audioscrobbler_do_handshake_cb (SoupMessage *msg, gpointer user_data);
 static void	     rb_audioscrobbler_submit_queue_cb (SoupMessage *msg, gpointer user_data);
+#endif
 
 static void	     rb_audioscrobbler_import_settings (RBAudioscrobbler *audioscrobbler);
 static void	     rb_audioscrobbler_preferences_sync (RBAudioscrobbler *audioscrobbler);
@@ -688,18 +695,31 @@
 static void
 rb_audioscrobbler_parse_response (RBAudioscrobbler *audioscrobbler, SoupMessage *msg)
 {
+	gboolean successful;
 	rb_debug ("Parsing response, status=%d", msg->status_code);
-
-	if (SOUP_STATUS_IS_SUCCESSFUL (msg->status_code) && (msg->response).body != NULL) {
-		gchar *body;
+	
+	successful = FALSE;
+#if defined(HAVE_LIBSOUP_2_4)
+	if (SOUP_STATUS_IS_SUCCESSFUL (msg->status_code) && msg->response_body->length != 0)
+		successful = TRUE;
+#else
+	if (SOUP_STATUS_IS_SUCCESSFUL (msg->status_code) && (msg->response).body != NULL)
+		successful = TRUE;
+#endif
+	if (successful) {
 		gchar **breaks;
+		int i;
+#if defined(HAVE_LIBSOUP_2_2)
+		gchar *body;
 
 		body = g_malloc0 ((msg->response).length + 1);
 		memcpy (body, (msg->response).body, (msg->response).length);
 
 		g_strstrip (body);
 		breaks = g_strsplit (body, "\n", 4);
-		int i;
+#else
+		breaks = g_strsplit (msg->response_body->data, "\n", 4);
+#endif
 
 		g_free (audioscrobbler->priv->status_msg);
 		audioscrobbler->priv->status = STATUS_OK;
@@ -771,10 +791,12 @@
 			audioscrobbler->priv->submit_next = time(NULL) + audioscrobbler->priv->submit_interval;
 
 		g_strfreev (breaks);
+#if defined(HAVE_LIBSOUP_2_2)
 		g_free (body);
+#endif
 	} else {
 		audioscrobbler->priv->status = REQUEST_FAILED;
-		audioscrobbler->priv->status_msg = g_strdup (soup_status_get_phrase (msg->status_code));
+		audioscrobbler->priv->status_msg = g_strdup (msg->reason_phrase);
 	}
 }
 
@@ -793,24 +815,25 @@
 rb_audioscrobbler_perform (RBAudioscrobbler *audioscrobbler,
 			   char *url,
 			   char *post_data,
-			   SoupMessageCallbackFn response_handler)
+			   SoupSessionCallback response_handler)
 {
 	SoupMessage *msg;
 
 	msg = soup_message_new (post_data == NULL ? "GET" : "POST", url);
+	soup_message_headers_append (msg->request_headers, "User-Agent", "Rhythmbox/" VERSION);
 
 	if (post_data != NULL) {
 		rb_debug ("Submitting to Audioscrobbler: %s", post_data);
 		soup_message_set_request (msg,
 					  "application/x-www-form-urlencoded",
-					  SOUP_BUFFER_SYSTEM_OWNED,
+					  SOUP_MEMORY_TAKE,
 					  post_data,
 					  strlen (post_data));
 	}
 
 	/* create soup session, if we haven't got one yet */
 	if (!audioscrobbler->priv->soup_session) {
-		SoupUri *uri;
+		SoupURI *uri;
 
 		uri = rb_proxy_config_get_libsoup_uri (audioscrobbler->priv->proxy_config);
 		audioscrobbler->priv->soup_session = soup_session_async_new_with_options (
@@ -891,8 +914,13 @@
 }
 
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+rb_audioscrobbler_do_handshake_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)
+#else
 static void
 rb_audioscrobbler_do_handshake_cb (SoupMessage *msg, gpointer user_data)
+#endif
 {
 	RBAudioscrobbler *audioscrobbler = RB_AUDIOSCROBBLER(user_data);
 
@@ -1049,8 +1077,13 @@
 	}
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+rb_audioscrobbler_submit_queue_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)
+#else
 static void
 rb_audioscrobbler_submit_queue_cb (SoupMessage *msg, gpointer user_data)
+#endif
 {
 	RBAudioscrobbler *audioscrobbler = RB_AUDIOSCROBBLER (user_data);
 
@@ -1232,7 +1265,7 @@
 rb_audioscrobbler_proxy_config_changed_cb (RBProxyConfig *config,
 					   RBAudioscrobbler *audioscrobbler)
 {
-	SoupUri *uri;
+	SoupURI *uri;
 
 	if (audioscrobbler->priv->soup_session) {
 		uri = rb_proxy_config_get_libsoup_uri (config);
diff -urN rhythmbox-0.11.4/plugins/audioscrobbler/rb-lastfm-gst-src.c rhythmbox-0.11.4.new/plugins/audioscrobbler/rb-lastfm-gst-src.c
--- rhythmbox-0.11.4/plugins/audioscrobbler/rb-lastfm-gst-src.c	2007-06-19 12:38:41.000000000 +0100
+++ rhythmbox-0.11.4.new/plugins/audioscrobbler/rb-lastfm-gst-src.c	2008-02-06 00:57:27.000000000 +0000
@@ -25,7 +25,6 @@
 
 #include "rb-debug.h"
 
-#include <libsoup/soup.h>
 #include <gst/gst.h>
 
 #define RB_TYPE_LASTFM_SRC (rb_lastfm_src_get_type())
diff -urN rhythmbox-0.11.4/plugins/audioscrobbler/rb-lastfm-source.c rhythmbox-0.11.4.new/plugins/audioscrobbler/rb-lastfm-source.c
--- rhythmbox-0.11.4/plugins/audioscrobbler/rb-lastfm-source.c	2007-12-04 03:05:39.000000000 +0000
+++ rhythmbox-0.11.4.new/plugins/audioscrobbler/rb-lastfm-source.c	2008-02-06 01:01:13.000000000 +0000
@@ -42,8 +42,8 @@
 
 #include <gconf/gconf-value.h>
 
+#include "rb-soup-compat.h"
 #include <libsoup/soup.h>
-#include <libsoup/soup-uri.h>
 
 #include "md5.h"
 
@@ -100,8 +100,12 @@
 static void rb_lastfm_perform (RBLastfmSource *lastfm,
 			       const char *url,
 			       char *post_data, /* this takes ownership */
-			       SoupMessageCallbackFn response_handler);
+			       SoupSessionCallback response_handler);
+#if defined(HAVE_LIBSOUP_2_4)
+static void rb_lastfm_message_cb (SoupSession *session, SoupMessage *req, gpointer user_data);
+#else
 static void rb_lastfm_message_cb (SoupMessage *req, gpointer user_data);
+#endif
 static void rb_lastfm_change_station (RBLastfmSource *source, const char *station);
 
 static void rb_lastfm_proxy_config_changed_cb (RBProxyConfig *config,
@@ -724,30 +728,29 @@
 rb_lastfm_perform (RBLastfmSource *source,
 		   const char *url,
 		   char *post_data,
-		   SoupMessageCallbackFn response_handler)
+		   SoupSessionCallback response_handler)
 {
 	SoupMessage *msg;
 	msg = soup_message_new ("GET", url);
+	soup_message_headers_append (msg->request_headers, "User-Agent", "Rhythmbox/" VERSION);
 
 	if (msg == NULL)
 		return;
 
-	soup_message_set_http_version (msg, SOUP_HTTP_1_1);
-
 	rb_debug ("Last.fm communicating with %s", url);
 
 	if (post_data != NULL) {
 		rb_debug ("POST data: %s", post_data);
 		soup_message_set_request (msg,
 					  "application/x-www-form-urlencoded",
-					  SOUP_BUFFER_SYSTEM_OWNED,
+					  SOUP_MEMORY_TAKE,
 					  post_data,
 					  strlen (post_data));
 	}
 
 	/* create soup session, if we haven't got one yet */
 	if (!source->priv->soup_session) {
-		SoupUri *uri;
+		SoupURI *uri;
 
 		uri = rb_proxy_config_get_libsoup_uri (source->priv->proxy_config);
 		source->priv->soup_session = soup_session_async_new_with_options (
@@ -759,27 +762,45 @@
 
 	soup_session_queue_message (source->priv->soup_session,
 				    msg,
-				    (SoupMessageCallbackFn) response_handler,
+				    response_handler,
 				    source);
 	source->priv->status = COMMUNICATING;
 	rb_source_notify_status_changed (RB_SOURCE(source));
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+rb_lastfm_message_cb (SoupSession *session, SoupMessage *req, gpointer user_data)
+#else
 static void
 rb_lastfm_message_cb (SoupMessage *req, gpointer user_data)
+#endif
 {
 	RBLastfmSource *source = RB_LASTFM_SOURCE (user_data);
-	char *body;
 	char **pieces;
 	int i;
+	const char *body;
+
+#if defined(HAVE_LIBSOUP_2_2)
+	char *free_body;
 
 	if ((req->response).body == NULL) {
 		rb_debug ("Lastfm: Server failed to respond");
 		return;
 	}
 
-	body = g_malloc0 ((req->response).length + 1);
-	memcpy (body, (req->response).body, (req->response).length);
+	free_body = g_malloc0 ((req->response).length + 1);
+	memcpy (free_body, (req->response).body, (req->response).length);
+	g_strstrip (free_body);
+
+	body = free_body;
+#else
+	if (req->response_body->length == 0) {
+		rb_debug ("Lastfm: Server failed to respond");
+		return;
+	}
+	body = req->response_body->data;
+#endif
 
 	rb_debug ("response body: %s", body);
 
@@ -787,7 +808,6 @@
 		source->priv->status = NO_ARTIST;
 	}
 
-	g_strstrip (body);
 	pieces = g_strsplit (body, "\n", 0);
 	for (i = 0; pieces[i] != NULL; i++) {
 		gchar **values = g_strsplit (pieces[i], "=", 2);
@@ -856,10 +876,14 @@
 			rhythmdb_commit (source->priv->db);
 
 		}
+
+		g_strfreev (values);
 	}
 
 	g_strfreev (pieces);
-	g_free (body);
+#if defined(HAVE_LIBSOUP_2_2)
+	g_free (free_body);
+#endif
 
 	/* doesn't work yet
 	if (source->priv->pending_entry) {
@@ -898,7 +922,7 @@
 rb_lastfm_proxy_config_changed_cb (RBProxyConfig *config,
 					   RBLastfmSource *source)
 {
-	SoupUri *uri;
+	SoupURI *uri;
 
 	if (source->priv->soup_session) {
 		uri = rb_proxy_config_get_libsoup_uri (config);
@@ -1163,10 +1187,16 @@
 	g_free(title);
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+rb_lastfm_source_metadata_cb (SoupSession *session, SoupMessage *req, RBLastfmSource *source)
+#else
 static void
 rb_lastfm_source_metadata_cb (SoupMessage *req, RBLastfmSource *source)
+#endif
 {
-	char *body;
+	const char *body;
+	char *free_body;
 	char **pieces;
 	int p;
 	RhythmDBEntry *entry;
@@ -1179,10 +1209,16 @@
 	}
 
 	rb_debug ("got response to metadata request");
-	body = g_malloc0 ((req->response).length + 1);
-	memcpy (body, (req->response).body, (req->response).length);
+#if defined(HAVE_LIBSOUP_2_4)
+	body = req->response_body->data;
+	free_body = NULL;
+#else
+	free_body = g_malloc0 ((req->response).length + 1);
+	memcpy (free_body, (req->response).body, (req->response).length);
+	g_strstrip (free_body);
+	body = free_body;
+#endif
 
-	g_strstrip (body);
 	pieces = g_strsplit (body, "\n", 0);
 	found_cover = FALSE;
 
@@ -1238,7 +1274,9 @@
 	}
 
 	g_strfreev (pieces);
-	g_free (body);
+#if defined(HAVE_LIBSOUP_2_2)
+	g_free (free_body);
+#endif
 
 	if (found_cover == FALSE) {
 		GValue v = {0,};
@@ -1271,7 +1309,7 @@
 			       source->priv->base_url,
 			       source->priv->base_path,
 			       source->priv->session);
-	rb_lastfm_perform (source, uri, NULL, (SoupMessageCallbackFn) rb_lastfm_source_metadata_cb);
+	rb_lastfm_perform (source, uri, NULL, (SoupSessionCallback) rb_lastfm_source_metadata_cb);
 	g_free (uri);
 
 	/* re-enable actions */
diff -urN rhythmbox-0.11.4/plugins/daap/rb-daap-connection.c rhythmbox-0.11.4.new/plugins/daap/rb-daap-connection.c
--- rhythmbox-0.11.4/plugins/daap/rb-daap-connection.c	2007-11-22 08:23:50.000000000 +0000
+++ rhythmbox-0.11.4.new/plugins/daap/rb-daap-connection.c	2008-02-06 00:57:27.000000000 +0000
@@ -33,10 +33,8 @@
 #include <glib/gi18n.h>
 #include <gdk/gdk.h>
 
+#include "rb-soup-compat.h"
 #include <libsoup/soup.h>
-#include <libsoup/soup-connection.h>
-#include <libsoup/soup-session-sync.h>
-#include <libsoup/soup-uri.h>
 
 #include "rb-daap-hash.h"
 #include "rb-daap-connection.h"
@@ -84,7 +82,7 @@
 	gboolean is_connecting;
 
 	SoupSession *session;
-	SoupUri *base_uri;
+	SoupURI *base_uri;
 	gchar *daap_base_uri;
 
 	gdouble daap_version;
@@ -329,7 +327,7 @@
 {
 	RBDAAPConnectionPrivate *priv = connection->priv;
 	SoupMessage *message = NULL;
-	SoupUri *uri = NULL;
+	SoupURI *uri = NULL;
 
 	uri = soup_uri_new_with_base (priv->base_uri, path);
 	if (uri == NULL) {
@@ -337,14 +335,13 @@
 	}
 
 	message = soup_message_new_from_uri (SOUP_METHOD_GET, uri);
-	soup_message_set_http_version (message, SOUP_HTTP_1_1);
 
-	soup_message_add_header (message->request_headers, "Client-DAAP-Version", 	"3.0");
-	soup_message_add_header (message->request_headers, "Accept-Language", 		"en-us, en;q=5.0");
+	soup_message_headers_append (message->request_headers, "Client-DAAP-Version", 		"3.0");
+	soup_message_headers_append (message->request_headers, "Accept-Language", 		"en-us, en;q=5.0");
 #ifdef HAVE_LIBZ
-	soup_message_add_header (message->request_headers, "Accept-Encoding",		"gzip");
+	soup_message_headers_append (message->request_headers, "Accept-Encoding",		"gzip");
 #endif
-	soup_message_add_header (message->request_headers, "Client-DAAP-Access-Index", 	"2");
+	soup_message_headers_append (message->request_headers, "Client-DAAP-Access-Index", 	"2");
 
 	if (priv->password_protected) {
 		char *h;
@@ -352,13 +349,17 @@
 		char *token;
 
 		user_pass = g_strdup_printf ("%s:%s", priv->username, priv->password);
+#if defined(HAVE_LIBSOUP_2_4)
+		token = g_base64_encode ((guchar *)user_pass, strlen (user_pass));
+#else
 		token = soup_base64_encode (user_pass, strlen (user_pass));
+#endif
 		h = g_strdup_printf ("Basic %s", token);
 
 		g_free (token);
 		g_free (user_pass);
 
-		soup_message_add_header (message->request_headers, "Authorization", h);
+		soup_message_headers_append (message->request_headers, "Authorization", h);
 		g_free (h);
 	}
 
@@ -372,10 +373,10 @@
 
 		rb_daap_hash_generate ((short)floor (version), (const guchar*)no_daap_path, 2, (guchar*)hash, req_id);
 
-		soup_message_add_header (message->request_headers, "Client-DAAP-Validation", hash);
+		soup_message_headers_append (message->request_headers, "Client-DAAP-Validation", hash);
 	}
 	if (send_close) {
-		soup_message_add_header (message->request_headers, "Connection", "close");
+		soup_message_headers_append (message->request_headers, "Connection", "close");
 	}
 
 	soup_uri_free (uri);
@@ -425,16 +426,22 @@
 {
 	RBDAAPConnectionPrivate *priv;
 	GNode *structure;
-	char *response;
+	char *new_response = NULL;
+	const char *response;
 	const char *encoding_header;
 	char *message_path;
 	int response_length;
 
 	priv = data->connection->priv;
 	structure = NULL;
-	response = data->message->response.body;
 	encoding_header = NULL;
+#if defined(HAVE_LIBSOUP_2_4)
+	response = data->message->response_body->data;
+	response_length = data->message->response_body->length;
+#else
+	response = data->message->response.body;
 	response_length = data->message->response.length;
+#endif
 
 	message_path = soup_uri_to_string (soup_message_get_uri (data->message), FALSE);
 
@@ -444,13 +451,12 @@
 		  data->message->reason_phrase);
 
 	if (data->message->response_headers) {
-		encoding_header = soup_message_get_header (data->message->response_headers, "Content-Encoding");
+		encoding_header = soup_message_headers_get (data->message->response_headers, "Content-Encoding");
 	}
 
 	if (SOUP_STATUS_IS_SUCCESSFUL (data->status) && encoding_header && strcmp (encoding_header, "gzip") == 0) {
 #ifdef HAVE_LIBZ
 		z_stream stream;
-		char *new_response;
 		unsigned int factor = 4;
 		unsigned int unc_size = response_length * factor;
 
@@ -575,19 +581,23 @@
 		rb_daap_structure_destroy (structure);
 	}
 
-	if (response != data->message->response.body) {
-		g_free (response);
-	}
-
+	g_free (new_response);
 	g_free (message_path);
 	g_object_unref (G_OBJECT (data->connection));
 	g_object_unref (G_OBJECT (data->message));
 	g_free (data);
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+http_response_handler (SoupSession      *session,
+		       SoupMessage      *message,
+		       RBDAAPConnection *connection)
+#else
 static void
 http_response_handler (SoupMessage      *message,
 		       RBDAAPConnection *connection)
+#endif
 {
 	DAAPResponseData *data;
 	int response_length;
@@ -599,7 +609,11 @@
 
 	data = g_new0 (DAAPResponseData, 1);
 	data->status = message->status_code;
+#if defined(HAVE_LIBSOUP_2_4)
+	response_length = message->response_body->length;
+#else
 	response_length = message->response.length;
+#endif
 
 	g_object_ref (G_OBJECT (connection));
 	data->connection = connection;
@@ -655,7 +669,7 @@
 	priv->use_response_handler_thread = use_thread;
 	priv->response_handler = handler;
 	soup_session_queue_message (priv->session, message,
-				    (SoupMessageCallbackFn) http_response_handler,
+				    (SoupSessionCallback) http_response_handler,
 				    connection);
 	rb_debug ("Queued message for http://%s:%d/%s",
 		  priv->base_uri->host,
@@ -1662,7 +1676,11 @@
 		char *token;
 
 		user_pass = g_strdup_printf ("%s:%s", priv->username, priv->password);
+#if defined(HAVE_LIBSOUP_2_4)
+		token = g_base64_encode ((guchar *)user_pass, strlen (user_pass));
+#else
 		token = soup_base64_encode (user_pass, strlen (user_pass));
+#endif
 		g_string_append_printf (headers, "Authentication: Basic %s\r\n", token);
 		g_free (token);
 		g_free (user_pass);
diff -urN rhythmbox-0.11.4/plugins/daap/rb-daap-plugin.c rhythmbox-0.11.4.new/plugins/daap/rb-daap-plugin.c
--- rhythmbox-0.11.4/plugins/daap/rb-daap-plugin.c	2007-09-03 08:24:09.000000000 +0100
+++ rhythmbox-0.11.4.new/plugins/daap/rb-daap-plugin.c	2008-02-06 00:57:27.000000000 +0000
@@ -29,8 +29,8 @@
 #include <glib.h>
 #include <glib-object.h>
 
+#include "rb-soup-compat.h"
 #include <libsoup/soup.h>
-#include <libsoup/soup-address.h>
 
 #include "rb-daap-plugin.h"
 #include "rb-debug.h"
@@ -647,6 +647,9 @@
 	g_free (host);
 
 	soup_address_resolve_async (addr,
+#if defined(HAVE_LIBSOUP_2_4)
+				    NULL, NULL,
+#endif
 				    (SoupAddressCallback) new_daap_share_resolve_cb,
 				    data);
 }
diff -urN rhythmbox-0.11.4/plugins/daap/rb-daap-share.c rhythmbox-0.11.4.new/plugins/daap/rb-daap-share.c
--- rhythmbox-0.11.4/plugins/daap/rb-daap-share.c	2007-11-08 13:09:20.000000000 +0000
+++ rhythmbox-0.11.4.new/plugins/daap/rb-daap-share.c	2008-02-06 00:57:27.000000000 +0000
@@ -27,13 +27,9 @@
 
 #include <glib/gi18n.h>
 #include <gtk/gtk.h>
+
+#include "rb-soup-compat.h"
 #include <libsoup/soup.h>
-#include <libsoup/soup-address.h>
-#include <libsoup/soup-message.h>
-#include <libsoup/soup-uri.h>
-#include <libsoup/soup-server.h>
-#include <libsoup/soup-server-auth.h>
-#include <libsoup/soup-server-message.h>
 #include <libgnomevfs/gnome-vfs.h>
 
 #include "rb-daap-share.h"
@@ -513,20 +509,22 @@
 static void
 message_add_standard_headers (SoupMessage *message)
 {
+#if defined(HAVE_LIBSOUP_2_2)
 	gchar *s;
 	time_t t;
 	struct tm *tm;
 
-	soup_message_add_header (message->response_headers, "DAAP-Server", "Rhythmbox " VERSION);
-
-	soup_message_add_header (message->response_headers, "Content-Type", "application/x-dmap-tagged");
-
 	t = time (NULL);
 	tm = gmtime (&t);
 	s = g_new (gchar, 100);
 	strftime (s, 100, "%a, %d %b %Y %T GMT", tm);
-	soup_message_add_header (message->response_headers, "Date", s);
+	soup_message_headers_append (message->response_headers, "Date", s);
 	g_free (s);
+#endif
+	
+	soup_message_headers_append (message->response_headers, "DAAP-Server", "Rhythmbox " VERSION);
+
+	soup_message_headers_append (message->response_headers, "Content-Type", "application/x-dmap-tagged");
 }
 
 static void
@@ -543,14 +541,15 @@
 		return;
 	}
 
-	message->response.owner = SOUP_BUFFER_SYSTEM_OWNED;
-	message->response.length = length;
-	message->response.body = resp;
+	soup_message_set_response (message, "application/x-dmap-tagged", SOUP_MEMORY_TAKE, resp, length);
+
+#if defined(HAVE_LIBSOUP_2_2)
+	soup_server_message_set_encoding (SOUP_SERVER_MESSAGE (message), SOUP_TRANSFER_CONTENT_LENGTH);
+#endif
 
 	message_add_standard_headers (message);
 
 	soup_message_set_status (message, SOUP_STATUS_OK);
-	soup_server_message_set_encoding (SOUP_SERVER_MESSAGE (message), SOUP_TRANSFER_CONTENT_LENGTH);
 }
 
 #define DMAP_STATUS_OK 200
@@ -559,10 +558,20 @@
 #define DAAP_VERSION 3.0
 #define DMAP_TIMEOUT 1800
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+server_info_cb (SoupServer        *server,
+		SoupMessage       *message,
+		const char        *path,
+		GHashTable        *query,
+		SoupClientContext *context,
+		RBDAAPShare       *share)
+#else
 static void
 server_info_cb (RBDAAPShare *share,
 		SoupServerContext *context,
 		SoupMessage *message)
+#endif
 {
 /* MSRV	server info response
  * 	MSTT status
@@ -619,10 +628,20 @@
 	rb_daap_structure_destroy (msrv);
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+content_codes_cb (SoupServer        *server,
+		  SoupMessage       *message,
+		  const char        *path,
+		  GHashTable        *query,
+		  SoupClientContext *context,
+		  RBDAAPShare       *share)
+#else
 static void
 content_codes_cb (RBDAAPShare *share,
 		  SoupServerContext *context,
 		  SoupMessage *message)
+#endif
 {
 /* MCCR content codes response
  * 	MSTT status
@@ -656,6 +675,48 @@
 	rb_daap_structure_destroy (mccr);
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static gboolean
+get_session_id (GHashTable *query,
+		guint32    *id)
+{
+	char *session_id_str;
+	guint32 session_id;
+
+	session_id_str = g_hash_table_lookup (query, "session-id");
+	if (session_id_str == NULL) {
+		rb_debug ("session id not found");
+		return FALSE;
+	}
+
+	session_id = (guint32) strtoul (session_id_str, NULL, 10);
+	if (id != NULL) {
+		*id = session_id;
+	}
+	return TRUE;
+}
+
+static gboolean
+get_revision_number (GHashTable *query,
+		     guint *number)
+{
+	char *revision_number_str;
+	guint revision_number;
+
+	revision_number_str = g_hash_table_lookup (query, "revision-number");
+	if (revision_number_str == NULL) {
+		rb_debug ("client asked for an update without a revision number?!?");
+		return FALSE;
+	}
+
+	revision_number = strtoul (revision_number_str, NULL, 10);
+	if (number != NULL) {
+		*number = revision_number;
+	}
+	return TRUE;
+}
+
+#else
 static gboolean
 message_get_session_id (SoupMessage *message,
 			guint32     *id)
@@ -729,11 +790,13 @@
 
 	return TRUE;
 }
+#endif
 
 static gboolean
 session_id_validate (RBDAAPShare       *share,
-		     SoupServerContext *context,
+		     SoupClientContext *context,
 		     SoupMessage       *message,
+		     GHashTable        *query,		/* NULL w/ libsoup 2.2 */
 		     guint32           *id)
 {
 	guint32     session_id;
@@ -745,7 +808,11 @@
 		*id = 0;
 	}
 
+#if defined(HAVE_LIBSOUP_2_4)
+	res = get_session_id (query, &session_id);
+#else
 	res = message_get_session_id (message, &session_id);
+#endif
 	if (! res) {
 		rb_debug ("Validation failed: Unable to parse session id from message");
 		return FALSE;
@@ -758,7 +825,7 @@
 		return FALSE;
 	}
 
-	remote_address = soup_server_context_get_client_host (context);
+	remote_address = soup_client_context_get_host (context);
 	rb_debug ("Validating session id %u from %s matches %s",
 		  session_id, remote_address, addr);
 	if (remote_address == NULL || strcmp (addr, remote_address) != 0) {
@@ -775,7 +842,7 @@
 
 static guint32
 session_id_generate (RBDAAPShare       *share,
-		     SoupServerContext *context)
+		     SoupClientContext *context)
 {
 	guint32 id;
 
@@ -786,7 +853,7 @@
 
 static guint32
 session_id_create (RBDAAPShare       *share,
-		   SoupServerContext *context)
+		   SoupClientContext *context)
 {
 	guint32     id;
 	const char *addr;
@@ -802,7 +869,7 @@
 	} while	(addr != NULL);
 
 	/* store session id and remote address */
-	remote_address = g_strdup (soup_server_context_get_client_host (context));
+	remote_address = g_strdup (soup_client_context_get_host (context));
 	g_hash_table_insert (share->priv->session_ids, GUINT_TO_POINTER (id), remote_address);
 
 	return id;
@@ -810,16 +877,26 @@
 
 static void
 session_id_remove (RBDAAPShare       *share,
-		   SoupServerContext *context,
+		   SoupClientContext *context,
 		   guint32            id)
 {
 	g_hash_table_remove (share->priv->session_ids, GUINT_TO_POINTER (id));
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
 static void
-login_cb (RBDAAPShare *share,
+login_cb (SoupServer        *server,
+	  SoupMessage       *message,
+	  const char        *path,
+	  GHashTable        *query,
+	  SoupClientContext *context,
+	  RBDAAPShare       *share)
+#else
+static void
+login_cb (RBDAAPShare       *share,
 	  SoupServerContext *context,
-	  SoupMessage *message)
+	  SoupMessage       *message)
+#endif
 {
 /* MLOG login response
  * 	MSTT status
@@ -840,15 +917,28 @@
 	rb_daap_structure_destroy (mlog);
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+logout_cb (SoupServer        *server,
+	   SoupMessage       *message,
+	   const char        *path,
+	   GHashTable        *query,
+	   SoupClientContext *context,
+	   RBDAAPShare       *share)
+#else
 static void
 logout_cb (RBDAAPShare *share,
 	   SoupServerContext *context,
 	   SoupMessage *message)
+#endif
 {
 	int     status;
 	guint32 id;
+#if defined(HAVE_LIBSOUP_2_2)
+	GHashTable *query = NULL;
+#endif
 
-	if (session_id_validate (share, context, message, &id)) {
+	if (session_id_validate (share, context, message, query, &id)) {
 		rb_debug ("Handling logout session id %u", id);
 		session_id_remove (share, context, id);
 
@@ -858,18 +948,34 @@
 	}
 
 	soup_message_set_status (message, status);
+#if defined(HAVE_LIBSOUP_2_2)
 	soup_server_message_set_encoding (SOUP_SERVER_MESSAGE (message), SOUP_TRANSFER_CONTENT_LENGTH);
+#endif
 }
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+update_cb (SoupServer        *server,
+	   SoupMessage       *message,
+	   const char        *path,
+	   GHashTable        *query,
+	   SoupClientContext *context,
+	   RBDAAPShare       *share)
+#else
 static void
 update_cb (RBDAAPShare *share,
 	   SoupServerContext *context,
 	   SoupMessage *message)
+#endif
 {
 	guint    revision_number;
 	gboolean res;
 
+#if defined(HAVE_LIBSOUP_2_4)
+	res = get_revision_number (query, &revision_number);
+#else
 	res = message_get_revision_number (message, &revision_number);
+#endif
 
 	if (res && revision_number != share->priv->revision_number) {
 		/* MUPD update response
@@ -885,8 +991,15 @@
 		message_set_from_rb_daap_structure (message, mupd);
 		rb_daap_structure_destroy (mupd);
 	} else {
+		/* FIXME: This seems like a bug. It just leaks the
+		 * message (and socket) without ever replying.
+		 */
 		g_object_ref (message);
+#if defined(HAVE_LIBSOUP_2_4)
+		soup_server_pause_message (server, message);
+#else
 		soup_message_io_pause (message);
+#endif
 	}
 }
 
@@ -1148,14 +1261,47 @@
 }
 
 static bitwise
+parse_meta_str (const char *attrs)
+{
+	gchar **attrsv;
+	guint i;
+	bitwise bits = 0;
+	
+	attrsv = g_strsplit (attrs, ",", -1);
+
+	for (i = 0; attrsv[i]; i++) {
+		guint j;
+
+		for (j = 0; j < G_N_ELEMENTS (meta_data_map); j++) {
+			if (strcmp (meta_data_map[j].tag, attrsv[i]) == 0) {
+				bits |= (((bitwise) 1) << meta_data_map[j].md);
+			}
+		}
+	}
+	
+	g_strfreev (attrsv);
+
+	return bits;
+}
+
+#if defined(HAVE_LIBSOUP_2_4)
+static bitwise
+parse_meta (GHashTable *query)
+{
+	const gchar *attrs;
+
+	attrs = g_hash_table_lookup (query, "meta");
+	return parse_meta_str (attrs);
+}
+
+#else
+static bitwise
 parse_meta (const gchar *s)
 {
+	bitwise bits;
 	gchar *start_of_attrs;
 	gchar *end_of_attrs;
 	gchar *attrs;
-	gchar **attrsv;
-	guint i;
-	bitwise bits = 0;
 
 	start_of_attrs = strstr (s, "meta=");
 	if (start_of_attrs == NULL) {
@@ -1170,23 +1316,12 @@
 		attrs = g_strdup (start_of_attrs);
 	}
 
-	attrsv = g_strsplit (attrs,",",-1);
-
-	for (i = 0; attrsv[i]; i++) {
-		guint j;
-
-		for (j = 0; j < G_N_ELEMENTS (meta_data_map); j++) {
-			if (strcmp (meta_data_map[j].tag, attrsv[i]) == 0) {
-				bits |= (((bitwise) 1) << meta_data_map[j].md);
-			}
-		}
-	}
-
+	bits = parse_meta_str (attrs);
 	g_free (attrs);
-	g_strfreev (attrsv);
 
 	return bits;
 }
+#endif
 
 static void
 write_next_chunk (SoupMessage *message, GnomeVFSHandle *handle)
@@ -1197,10 +1332,18 @@
 
 	result = gnome_vfs_read (handle, chunk, DAAP_SHARE_CHUNK_SIZE, &read_size);
 	if (result == GNOME_VFS_OK && read_size > 0) {
+#if defined(HAVE_LIBSOUP_2_4)
+		soup_message_body_append (message->response_body, SOUP_MEMORY_TAKE, chunk, read_size);
+#else
 		soup_message_add_chunk (message, SOUP_BUFFER_SYSTEM_OWNED, chunk, read_size);
+#endif
 	} else {
 		g_free (chunk);
+#if defined(HAVE_LIBSOUP_2_4)
+		soup_message_body_complete (message->response_body);
+#else
 		soup_message_add_final_chunk (message);
+#endif
 	}
 }
 
@@ -1238,7 +1381,11 @@
 		file_size -= offset;
 	}
 
+#if defined(HAVE_LIBSOUP_2_4)
+	soup_message_headers_set_encoding (message->response_headers, SOUP_ENCODING_CHUNKED);
+#else
 	soup_server_message_set_encoding (SOUP_SERVER_MESSAGE (message), SOUP_TRANSFER_CHUNKED);
+#endif
 
 	g_signal_connect (message, "wrote_chunk", G_CALLBACK (write_next_chunk), handle);
 	g_signal_connect (message, "finished", G_CALLBACK (chunked_message_finished), handle);
@@ -1268,11 +1415,14 @@
 		g_warning ("Unable to map file %s: %s", path, error->message);
 		soup_message_set_status (message, SOUP_STATUS_INTERNAL_SERVER_ERROR);
 	} else {
-		message->response.owner = SOUP_BUFFER_USER_OWNED;
-		message->response.length = file_size;
-		message->response.body = g_mapped_file_get_contents (mapped_file) + offset;
+		soup_message_set_response (message, "application/x-dmap-tagged",
+					   SOUP_MEMORY_TEMPORARY,
+					   g_mapped_file_get_contents (mapped_file) + offset,
+					   file_size);
+#if defined(HAVE_LIBSOUP_2_2)
 		soup_server_message_set_encoding (SOUP_SERVER_MESSAGE (message),
 						  SOUP_TRANSFER_CONTENT_LENGTH);
+#endif
 
 		g_signal_connect (message,
 				  "finished",
@@ -1283,22 +1433,40 @@
 }
 #endif
 
+#if defined(HAVE_LIBSOUP_2_4)
+static void
+databases_cb (SoupServer        *server,
+	      SoupMessage       *message,
+	      const char        *path,
+	      GHashTable        *query,
+	      SoupClientContext *context,
+	      RBDAAPShare       *share)
+
+#else
 static void
 databases_cb (RBDAAPShare *share,
 	      SoupServerContext *context,
 	      SoupMessage *message)
+#endif
 {
-	gchar *path;
-	gchar *rest_of_path;
+	const char *rest_of_path;
 	/*guint revision_number;*/
+#if defined(HAVE_LIBSOUP_2_2)
+	GHashTable *query = NULL;
+	gchar *path;
+#endif
 
-	if (! session_id_validate (share, context, message, NULL)) {
+	if (! session_id_validate (share, context, message, query, NULL)) {
 		soup_message_set_status (message, SOUP_STATUS_FORBIDDEN);
+#if defined(HAVE_LIBSOUP_2_2)
 		soup_server_message_set_encoding (SOUP_SERVER_MESSAGE (message), SOUP_TRANSFER_CONTENT_LENGTH);
+#endif
 		return;
 	}
 
+#if defined(HAVE_LIBSOUP_2_2)
 	path = soup_uri_to_string (soup_message_get_uri (message), TRUE);
+#endif
 
 	rest_of_path = strchr (path + 1, '/');
 
@@ -1335,7 +1503,11 @@
 
 		message_set_from_rb_daap_structure (message, avdb);
 		rb_daap_structure_destroy (avdb);
+#if defined(HAVE_LIBSOUP_2_4)
+	} else if (g_ascii_strcasecmp ("/1/items", rest_of_path) == 0) {
+#else
 	} else if (g_ascii_strncasecmp ("/1/items?", rest_of_path, 9) == 0) {
+#endif
 	/* ADBS database songs
 	 * 	MSTT status
 	 * 	MUTY update type
@@ -1351,7 +1523,11 @@
 		gint32 num_songs = rhythmdb_entry_count_by_type (share->priv->db, share->priv->entry_type);
 		struct MLCL_Bits mb = {NULL,0};
 
+#if defined(HAVE_LIBSOUP_2_4)
+		mb.bits = parse_meta (query);
+#else
 		mb.bits = parse_meta (rest_of_path);
+#endif
 
 		adbs = rb_daap_structure_add (NULL, RB_DAAP_CC_ADBS);
 		rb_daap_structure_add (adbs, RB_DAAP_CC_MSTT, (gint32) DMAP_STATUS_OK);
@@ -1365,7 +1541,11 @@
 		message_set_from_rb_daap_structure (message, adbs);
 		rb_daap_structure_destroy (adbs);
 		adbs = NULL;
+#if defined(HAVE_LIBSOUP_2_4)
+	} else if (g_ascii_strcasecmp ("/1/containers", rest_of_path) == 0) {
+#else
 	} else if (g_ascii_strncasecmp ("/1/containers?", rest_of_path, 14) == 0) {
+#endif
 	/* APLY database playlists
 	 * 	MSTT status
 	 * 	MUTY update type
@@ -1402,6 +1582,7 @@
 
 		message_set_from_rb_daap_structure (message, aply);
 		rb_daap_structure_destroy (aply);
+
 	} else if (g_ascii_strncasecmp ("/1/containers/", rest_of_path, 14) == 0) {
 	/* APSO playlist songs
 	 * 	MSTT status
@@ -1420,7 +1601,11 @@
 		struct MLCL_Bits mb = {NULL,0};
 		gint pl_id = atoi (rest_of_path + 14);
 
+#if defined(HAVE_LIBSOUP_2_4)
+		mb.bits = parse_meta (query);
+#else
 		mb.bits = parse_meta (rest_of_path);
+#endif
 
 		apso = rb_daap_structure_add (NULL, RB_DAAP_CC_APSO);
 		rb_daap_structure_add (apso, RB_DAAP_CC_MSTT, (gint32) DMAP_STATUS_OK);
@@ -1447,9 +1632,11 @@
 						  _find_by_id);
 			if (idl == NULL) {
 				soup_message_set_status (message, SOUP_STATUS_NOT_FOUND);
+#if defined(HAVE_LIBSOUP_2_2)
 				soup_server_message_set_encoding (SOUP_SERVER_MESSAGE (message),
 								  SOUP_TRANSFER_CONTENT_LENGTH);
 				soup_message_set_response (message, "text/plain", SOUP_BUFFER_USER_OWNED, "", 0);
+#endif
 				goto out;
 			}
 			id = (RBPlaylistID *)idl->data;
@@ -1470,7 +1657,7 @@
 		rb_daap_structure_destroy (apso);
 	} else if (g_ascii_strncasecmp ("/1/items/", rest_of_path, 9) == 0) {
 	/* just the file :) */
-		gchar *id_str;
+		const gchar *id_str;
 		gint id;
 		RhythmDBEntry *entry;
 		const gchar *location;
@@ -1486,9 +1673,9 @@
 		file_size = rhythmdb_entry_get_uint64 (entry, RHYTHMDB_PROP_FILE_SIZE);
 
 		message_add_standard_headers (message);
-		soup_message_add_header (message->response_headers, "Accept-Ranges", "bytes");
+		soup_message_headers_append (message->response_headers, "Accept-Ranges", "bytes");
 
-		range_header = soup_message_get_header (message->request_headers, "Range");
+		range_header = soup_message_headers_get (message->request_headers, "Range");
 		if (range_header) {
 			const gchar *s;
 			gchar *content_range;
@@ -1497,7 +1684,7 @@
 			offset = atoll (s);
 
 			content_range = g_strdup_printf ("bytes %" G_GUINT64_FORMAT "-%" G_GUINT64_FORMAT "/%" G_GUINT64_FORMAT, offset, file_size, file_size);
-			soup_message_add_header (message->response_headers, "Content-Range", content_range);
+			soup_message_headers_append (message->response_headers, "Content-Range", content_range);
 			g_free (content_range);
 
 			soup_message_set_status (message, SOUP_STATUS_PARTIAL_CONTENT);
@@ -1522,9 +1709,92 @@
 	}
 
 out:
+#if defined(HAVE_LIBSOUP_2_2)
 	g_free (path);
+#else
+	;
+#endif
+}
+
+static void
+db_entry_added_cb (RhythmDB *db,
+		   RhythmDBEntry *entry,
+		   RBDAAPShare *share)
+{
+	/* TODO: update our db version number? */
+}
+
+static void
+add_db_entry (RhythmDBEntry *entry,
+	      RBDAAPShare *share)
+{
+	db_entry_added_cb (share->priv->db, entry, share);
+}
+
+static void
+db_entry_deleted_cb (RhythmDB *db,
+		     RhythmDBEntry *entry,
+		     RBDAAPShare *share)
+{
+	/* TODO: update our db version number? */
+}
+
+static void
+db_entry_changed_cb (RhythmDB *db,
+		     RhythmDBEntry *entry,
+		     GSList *changes,
+		     RBDAAPShare *share)
+{
+	if (rhythmdb_entry_get_boolean (entry, RHYTHMDB_PROP_HIDDEN)) {
+		db_entry_deleted_cb (db, entry, share);
+	} else {
+		db_entry_added_cb (db, entry, share);
+	}
+}
+
+#if defined(HAVE_LIBSOUP_2_4)
+
+static gboolean
+soup_auth_filter (SoupAuthDomain *auth_domain,
+		  SoupMessage    *msg,
+		  gpointer        user_data)
+{
+	const char *path;
+
+	path = soup_message_get_uri (msg)->path;
+	if (g_str_has_prefix (path, "/databases/")) {
+		/* Subdirectories of /databases don't actually require
+		 * authentication
+		 */
+		return FALSE;
+	} else {
+		/* Everything else in auth_domain's paths, including
+		 * /databases itself, does require auth.
+		 */
+		return TRUE;
+	}
 }
 
+static gboolean
+soup_auth_callback (SoupAuthDomain *auth_domain,
+		    SoupMessage    *msg,
+		    const char     *username,
+		    gpointer        password,
+		    RBDAAPShare    *share)
+{
+	gboolean    allowed;
+	const char *path;
+
+	path = soup_message_get_uri (msg)->path;
+	rb_debug ("Auth request for %s, user %s", path, username);
+
+	allowed = !strcmp (password, share->priv->password);
+	rb_debug ("Auth request: %s", allowed ? "ALLOWED" : "DENIED");
+
+	return allowed;
+}
+
+#else
 typedef void (* DAAPPathFunction) (RBDAAPShare       *share,
 				   SoupServerContext *context,
 				   SoupMessage       *message);
@@ -1567,42 +1837,6 @@
 	g_free (path);
 }
 
-static void
-db_entry_added_cb (RhythmDB *db,
-		   RhythmDBEntry *entry,
-		   RBDAAPShare *share)
-{
-	/* TODO: update our db version number? */
-}
-
-static void
-add_db_entry (RhythmDBEntry *entry,
-	      RBDAAPShare *share)
-{
-	db_entry_added_cb (share->priv->db, entry, share);
-}
-
-static void
-db_entry_deleted_cb (RhythmDB *db,
-		     RhythmDBEntry *entry,
-		     RBDAAPShare *share)
-{
-	/* TODO: update our db version number? */
-}
-
-static void
-db_entry_changed_cb (RhythmDB *db,
-		     RhythmDBEntry *entry,
-		     GSList *changes,
-		     RBDAAPShare *share)
-{
-	if (rhythmdb_entry_get_boolean (entry, RHYTHMDB_PROP_HIDDEN)) {
-		db_entry_deleted_cb (db, entry, share);
-	} else {
-		db_entry_added_cb (db, entry, share);
-	}
-}
-
 static gboolean
 soup_auth_callback (SoupServerAuthContext *auth_ctx,
                     SoupServerAuth        *auth,
@@ -1642,12 +1876,14 @@
 	return allowed;
 }
 
+#endif
+
+
 static gboolean
 rb_daap_share_server_start (RBDAAPShare *share)
 {
 	int                   port = STANDARD_DAAP_PORT;
 	gboolean              password_required;
-	SoupServerAuthContext auth_ctx = { 0 };
 
 	share->priv->server = soup_server_new (SOUP_SERVER_PORT, port, NULL);
 	if (share->priv->server == NULL) {
@@ -1666,6 +1902,22 @@
 	password_required = (share->priv->auth_method != RB_DAAP_SHARE_AUTH_METHOD_NONE);
 
 	if (password_required) {
+#if defined(HAVE_LIBSOUP_2_4)
+		SoupAuthDomain *auth_domain;
+
+		auth_domain = soup_auth_domain_basic_new (SOUP_AUTH_DOMAIN_REALM, "Music Sharing",
+							  SOUP_AUTH_DOMAIN_ADD_PATH, "/login",
+							  SOUP_AUTH_DOMAIN_ADD_PATH, "/update",
+							  SOUP_AUTH_DOMAIN_ADD_PATH, "/database",
+							  SOUP_AUTH_DOMAIN_FILTER, soup_auth_filter,
+							  NULL);
+		soup_auth_domain_basic_set_auth_callback (auth_domain,
+							  (SoupAuthDomainBasicAuthCallback)soup_auth_callback,
+							  g_object_ref (share),
+							  g_object_unref);
+		soup_server_add_auth_domain (share->priv->server, auth_domain);
+#else
+		SoupServerAuthContext auth_ctx = { 0 };
 		auth_ctx.types = SOUP_AUTH_TYPE_BASIC;
 		auth_ctx.callback = (SoupServerAuthCallbackFn)soup_auth_callback;
 		auth_ctx.user_data = share;
@@ -1689,14 +1941,36 @@
 					 (SoupServerCallbackFn)server_cb,
 					 NULL,
 					 share);
+#endif
 	}
 
+#if defined(HAVE_LIBSOUP_2_4)
+	soup_server_add_handler (share->priv->server, "/server-info",
+				 (SoupServerCallback) server_info_cb,
+				 share, NULL);
+	soup_server_add_handler (share->priv->server, "/content-codes",
+				 (SoupServerCallback) content_codes_cb,
+				 share, NULL);
+	soup_server_add_handler (share->priv->server, "/login",
+				 (SoupServerCallback) login_cb,
+				 share, NULL);
+	soup_server_add_handler (share->priv->server, "/logout",
+				 (SoupServerCallback) logout_cb,
+				 share, NULL);
+	soup_server_add_handler (share->priv->server, "/update",
+				 (SoupServerCallback) update_cb,
+				 share, NULL);
+	soup_server_add_handler (share->priv->server, "/databases",
+				 (SoupServerCallback) databases_cb,
+				 share, NULL);
+#else
 	soup_server_add_handler (share->priv->server,
 				 NULL,
 				 NULL,
 				 (SoupServerCallbackFn)server_cb,
 				 NULL,
 				 share);
+#endif
 	soup_server_run_async (share->priv->server);
 
 	/* using direct since there is no g_uint_hash or g_uint_equal */
diff -urN rhythmbox-0.11.4/plugins/daap/rb-daap-src.c rhythmbox-0.11.4.new/plugins/daap/rb-daap-src.c
--- rhythmbox-0.11.4/plugins/daap/rb-daap-src.c	2007-06-17 12:56:21.000000000 +0100
+++ rhythmbox-0.11.4.new/plugins/daap/rb-daap-src.c	2008-02-06 00:57:27.000000000 +0000
@@ -34,8 +34,8 @@
 #include <unistd.h>
 #include <ctype.h>
 
-#include <libsoup/soup-headers.h>
-#include <libsoup/soup-misc.h>
+#include "rb-soup-compat.h"
+#include <libsoup/soup.h>
 
 #include <glib/gi18n.h>
 #include <gst/gst.h>
@@ -432,7 +432,12 @@
 	gchar *host;
 	guint port;
 	gchar *path;
+#if defined(HAVE_LIBSOUP_2_4)
+	SoupMessageHeaders *header_table;
+#else
 	GHashTable *header_table;
+	char *dup_headers;
+#endif
 	gchar *request;
 	gchar *response;
 	gchar *end_headers;
@@ -441,7 +446,6 @@
 	guint http_status;
 	gchar *http_status_phrase = NULL;
 	gboolean parse_result;
-	char *dup_headers;
 
 	if (src->buffer_base) {
 		g_free (src->buffer_base);
@@ -536,6 +540,15 @@
 		return FALSE;
 	}
 
+#if defined(HAVE_LIBSOUP_2_4)
+	header_table = soup_message_headers_new (SOUP_MESSAGE_HEADERS_RESPONSE);
+	parse_result = soup_headers_parse_response (response,
+						    ((end_headers+2) - response),
+						    header_table,
+						    NULL,
+						    &http_status,
+						    &http_status_phrase);
+#else
 	/* for compatibility with older versions of libsoup, we may need to retry
 	 * the soup_headers_parse_response call with slightly different arguments.
 	 * since this function modifies the string passed in, we need to copy it
@@ -567,28 +580,42 @@
 							    &http_status,
 							    &http_status_phrase);
 	}
+#endif
 
 	if (parse_result) {
 		if (http_status == 200 || http_status == 206) {
+			const char *enc_str = NULL;
+			const char *len_str = NULL;
+#if defined(HAVE_LIBSOUP_2_4)
+			enc_str = soup_message_headers_get (header_table, "Transfer-Encoding");
+			len_str = soup_message_headers_get (header_table, "Content-Length");
+#else
 			GSList *val;
-
 			val = g_hash_table_lookup (header_table, "Transfer-Encoding");
 			if (val) {
-				if (g_strcasecmp ((gchar *)val->data, "chunked") == 0) {
+				enc_str = ((const char *)val->data);
+			}
+			val = g_hash_table_lookup (header_table, "Content-Length");
+			if (val) {
+				len_str = ((const char *)val->data);
+			}
+#endif
+
+			if (enc_str) {
+				if (g_strcasecmp (enc_str, "chunked") == 0) {
 					src->chunked = TRUE;
 				} else {
 					GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ, (NULL),
-							   ("Unknown HTTP transfer encoding \"%s\"", val->data));
+							   ("Unknown HTTP transfer encoding \"%s\"", enc_str));
 				}
 			} else {
 				src->chunked = FALSE;
-				val = g_hash_table_lookup (header_table, "Content-Length");
-				if (val) {
+				if (len_str) {
 					char *e;
-					src->size = strtoul ((char *)val->data, &e, 10);
-					if (e == val->data) {
+					src->size = strtoul (len_str, &e, 10);
+					if (e == len_str) {
 						GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ, (NULL),
-								   ("Couldn't read HTTP content length \"%s\"", val->data));
+								   ("Couldn't read HTTP content length \"%s\"", len_str));
 						ok = FALSE;
 					}
 				} else {
@@ -609,8 +636,13 @@
 		ok = FALSE;
 	}
 	g_free (http_status_phrase);
+
+#if defined(HAVE_LIBSOUP_2_4)
+	soup_message_headers_free (header_table);
+#else
 	soup_message_clear_headers (header_table);
 	g_hash_table_destroy (header_table);
+#endif
 
 	end_headers += 4;
 
